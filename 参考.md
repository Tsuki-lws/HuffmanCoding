# 开发文档

## 1. 项目概述

本项目实现了一个基于 **霍夫曼编码** (Huffman Coding) 算法的文件压缩和解压工具，支持压缩和解压文件以及文件夹。项目支持图形用户界面（GUI）和命令行界面（CLI）两种操作方式，具备文件和文件夹的递归压缩解压、文件加密、错误提示等功能。用户可以通过该工具对大文件（>4GB）、空文件以及不同层级的文件夹进行压缩与解压，且支持文件加密和密码验证。

------

## 2. 项目结构

### 2.1 目录结构

```
com.example.huffman/
├── gui/                           // 图形界面相关
│   ├── CompressionGUI.java        // 主GUI界面类，提供文件操作的可视化界面
│   ├── GUIUtils.java             // 提供图形界面常用工具方法（居中显示、错误提示等）
│   └── StyledButton.java         // 样式化按钮，支持鼠标悬停效果
│
├── file/                          // 文件压缩解压相关
│   ├── FileCompressor.java       // 负责单个文件的压缩
│   ├── FileDecompressor.java     // 负责单个文件的解压
│   ├── FolderCompressor.java     // 负责文件夹的压缩
│   └── FolderDecompressor.java   // 负责文件夹的解压
│
├── compression/                   // 压缩算法相关
│   ├── HuffmanDecoder.java       // 霍夫曼解码器类，负责解压数据
│   ├── HuffmanEncoder.java       // 霍夫曼编码器类，负责压缩数据
│   ├── HuffmanNode.java          // 霍夫曼树的节点类，存储编码相关信息
│   └── HuffmanTree.java          // 霍夫曼树的构建与序列化类
│
├── utils/                         // 辅助工具类
│   ├── FileUtils.java            // 文件操作工具类（读取文件、写入文件等）
│   └── Utils.java                // 通用工具类（流操作、文件存在检查等）
│
├── Main.java                     // 程序入口，支持CLI和GUI模式
└── README.md                     // 项目文档，说明文件
```

### 2.2 主要类和功能

#### 1. `HuffmanEncoder` 类

- **功能**：实现霍夫曼编码，用于将输入数据压缩成哈夫曼编码形式。
- 核心方法：
  - `buildHuffmanCodes(byte[] data)`：构建霍夫曼编码表。
  - `encodeData(byte[] data, String[] huffmanCodes)`：根据构建的编码表对数据进行压缩。

#### 2. `HuffmanDecoder` 类

- **功能**：负责解压压缩后的数据，采用哈夫曼解码。
- 核心方法：
  - `decompressData(byte[] compressedData, HuffmanNode root, long fileSize)`：通过哈夫曼树解压数据。

#### 3. `HuffmanNode` 类

- **功能**：表示霍夫曼树中的一个节点，存储数据字节、频率以及左右子节点的信息。
- 核心方法：
  - `getByte()`：返回当前节点的数据字节。
  - `getFrequency()`：返回当前节点的频率。
  - `isLeaf()`：判断该节点是否为叶子节点。

#### 4. `HuffmanTree` 类

- **功能**：构建霍夫曼树，提供树的序列化与反序列化功能。
- 核心方法：
  - `buildTree(Map<Byte, Integer> frequencyMap)`：根据频率映射构建霍夫曼树。
  - `serializeTree(Node root, DataOutputStream out)`：将霍夫曼树序列化为字节流。
  - `deserializeTree(DataInputStream in)`：从字节流中反序列化出霍夫曼树。

#### 5. `FileCompressor` 类

- **功能**：对单个文件进行压缩，调用霍夫曼编码对数据进行处理。
- 核心方法：
  - `compress(String inputFilePath, String password, String outputFilePath, JProgressBar progressBar, boolean jumpPhoto)`：压缩文件，并支持加密。

#### 6. `FileDecompressor` 类

- **功能**：对压缩文件进行解压，恢复原文件内容。
- 核心方法：
  - `decompress(String inputFilePath, String password, String outputFilePath, JProgressBar progressBar)`：解压文件。

#### 7. `FolderCompressor` 类

- **功能**：对文件夹进行递归压缩，压缩文件夹内的文件和子文件夹。
- 核心方法：
  - `compressFolder(String folderPath, String password, String outputPath, JProgressBar progressBar, boolean jumpPhoto)`：压缩整个文件夹。

#### 8. `FolderDecompressor` 类

- **功能**：对文件夹进行递归解压，恢复文件夹内的文件和子文件夹。
- 核心方法：
  - `decompressFolder(String inputFilePath, String password, String outputPath, JProgressBar progressBar)`：解压文件夹。

#### 9. `CompressionGUI` 类

- **功能**：图形界面的主类，用户通过此界面进行文件压缩与解压操作。
- 核心功能：
  - 提供输入路径、输出路径、密码输入框和进度条等GUI组件，支持文件选择和操作。

#### 10. `GUIUtils` 和 `StyledButton` 类

- **功能**：提供图形界面的通用方法，设置按钮样式、居中窗口、显示错误消息等。

#### 11. `FileUtils` 和 `Utils` 类

- **功能**：提供文件和通用工具方法，如读取文件、检查文件是否存在等。

#### 12. `Main` 类

- **功能**：项目的入口，支持命令行和图形界面两种启动方式，根据用户输入执行相应操作。

------

## 3. 核心需求

### 3.1 文件的压缩与解压（30%）

#### 需求分析与实现：

- **功能**：支持压缩与解压文件，并保证压缩后的文件内容和原始文件一致。需要支持大文件（>4GB）和空文件的处理。
- **实现**：
  - 使用 **霍夫曼编码** 算法进行压缩，压缩后的文件大小应该小于原始文件。
  - 为避免处理大文件时的 `int` 溢出，所有文件大小计算使用 `long` 类型。
  - 对空文件的处理，直接返回大小为 0 的字节数组。

#### 解决方案：

- 在 `FileCompressor` 和 `FileDecompressor` 类中使用霍夫曼算法压缩和解压文件，确保解压后的数据与原数据一致。
- 采用 `long` 类型来处理大文件的大小，避免 `int` 类型溢出问题。
- 压缩时可以指定压缩包名称，解压时会自动恢复原文件名。

**压缩文件时的写入顺序如下**：

1. 文件头信息（密码、跳过图片的标志、文件大小、文件名、文件块数）。
2. 然后根据文件的大小分割成多个数据块。
3. 每个数据块的哈夫曼树和加密后的数据被按顺序写入压缩文件。
4. 在文件夹压缩时，文件夹元数据和每个文件的元数据都会被写入文件中，文件的数据块则依次压缩并写入。

------

### 3.2 文件夹的压缩与解压（20%）

#### 需求分析与实现：

- **功能**：支持压缩与解压文件夹，递归处理子文件夹。
- **实现**：
  - 使用递归方式遍历文件夹及其子文件夹，压缩所有文件及文件夹结构。
  - 对空文件夹压缩时，仅压缩文件夹结构，不包含文件内容。

#### 解决方案：

- `FolderCompressor` 类通过递归遍历文件夹中的每个文件和子文件夹，调用 `FileCompressor` 压缩文件。

- `FolderDecompressor` 类递归解压文件夹中的文件，恢复文件夹的结构。

    **在压缩文件夹时，存入内容的顺序大致如下：**

  1. **写入压缩文件头**：首先会写入压缩文件的基本信息，包括密码、是否跳过照片文件标志，以及文件夹名等。
  2. **写入文件数量与总大小**：接着会写入该文件夹下的文件总数和所有文件的总大小。
  3. **逐个文件写入元数据**：
     - 对每个文件，先写入该文件的**相对路径**。
     - 然后写入该文件的**大小**。
     - 继续写入该文件是否是一个**目录**。
  4. **压缩每个文件**：
     - 对于每个非空文件，进行压缩并存入压缩数据。
     - 每个文件会被分成多个压缩块，并按顺序依次压缩。
  5. **写入哈夫曼树和压缩数据**：每个文件的压缩数据和哈夫曼树结构会依次存储。
  6. **更新进度条**：在处理文件时，进度条根据已处理的文件大小更新。

------

### 3.3 设置压缩密码（15%）

#### 需求分析与实现：

- **功能**：在压缩时可以选择设置密码，解压时需要输入密码。
- **实现**：
  - 在压缩时，用户可以设置密码，密码可以直接编码进文件头中。
  - 如果文件是加密压缩的，解压时要求用户输入密码，若密码正确，则解压。

#### 解决方案：

- 压缩时，密码通过AES加密压缩文件内容，也直接将密码存储在压缩包头部。
- 顺带一提的是，因为AES本身是对称随机加密，所以加密出来的文件里面的字符频率都差不多，所以我对加密过的文件再次压缩基本只会变大。

------

- ### 3.4 代码风格（5%）

  #### 需求分析与实现

  **目标**：

  - 确保代码具备良好的可读性和可维护性，便于后续扩展和维护。
  - 遵循面向对象设计原则（**SOLID** 原则），实现代码的模块化、职责单一和低耦合。
  - 提供清晰的注释，帮助理解代码逻辑，特别是在复杂算法（如霍夫曼编码）和核心功能部分。

  **实现方案**：

  1. **模块化设计**：
     - 项目划分为多个功能模块，如压缩、解压、加密、用户交互和工具类模块。每个模块职责单一且功能明确。
     - 例如，`HuffmanEncoder` 负责数据编码，`HuffmanDecoder` 负责数据解码，而 `FileCompressor` 和 `FileDecompressor` 负责具体的文件压缩与解压。
  2. **避免代码冗长**：
     - 复杂逻辑被拆分为多个独立的私有方法。
     - 避免重复代码。例如，压缩与解压中的进度条更新逻辑被抽取到独立的工具方法。
  3. **清晰的注释和命名**：
     - 每个类和方法都有详细的 Javadoc 注释，清楚地描述其功能和参数。
     - 使用清晰的变量和方法命名，如 `compressData`、`decompressData` 等，避免晦涩难懂的名称。
  4. **可扩展性**：
     - 使用接口和抽象类（如 `HuffmanNode`）增强灵活性，便于未来扩展其他压缩算法。
     - 在 `FileCompressor` 中，使用多线程处理文件块压缩以提高性能，同时确保代码解耦。

  ------

  #### 示例代码说明

  以下是 `HuffmanEncoder` 类中 `buildHuffmanTree` 方法的实现，展示了代码清晰性、模块化和注释的优点：

  ```
  java复制代码/**
   * 构建霍夫曼树
   *
   * @param frequencyMap 频率映射表
   * @return 霍夫曼树的根节点
   */
  public static HuffmanNode buildHuffmanTree(int[] frequencyMap) {
      // 使用优先队列保证每次能够高效选出频率最低的两个节点
      PriorityQueue<HuffmanNode> queue = new PriorityQueue<>((a, b) -> Integer.compare(a.getFrequency(), b.getFrequency()));
      
      // 初始化优先队列，将每个字节的频率信息存储为叶子节点
      for (int i = 0; i < frequencyMap.length; i++) {
          if (frequencyMap[i] > 0) {
              queue.add(new HuffmanNode((byte) i, frequencyMap[i]));
          }
      }
  
      // 构建霍夫曼树
      while (queue.size() > 1) {
          HuffmanNode left = queue.poll();
          HuffmanNode right = queue.poll();
          // 创建父节点，频率为左右子节点频率之和
          HuffmanNode parent = new HuffmanNode(null, left.getFrequency() + right.getFrequency(), left, right);
          queue.add(parent);
      }
  
      // 返回霍夫曼树的根节点
      return queue.poll();
  }
  ```

  ------

  #### 优点分析

  1. **面向对象设计**：
     - 使用 `HuffmanNode` 类封装节点数据，包括字节值、频率和左右子节点，确保数据结构清晰。
     - `PriorityQueue` 的使用体现了设计模式中的策略模式，为节点的排序提供了高效的解决方案。
  2. **模块化**：
     - 将频率统计与霍夫曼树构建分为两个独立的方法，确保方法的单一职责。
     - 方法短小精悍，便于理解和测试。
  3. **注释清晰**：
     - 每段逻辑都提供了详细的注释，解释了为什么这样设计以及每一步的功能。

  通过这种代码风格，本项目实现了高效的开发和便捷的后续维护，并为扩展其他功能（如支持其他编码算法）奠定了良好的基础。

------

## 4. 其他需求

### 4.1 用户交互（5%）

#### 需求分析与实现：

- **功能**：用户通过命令行或图形界面输入操作指令。
- **实现**：
  - 在 `Main` 类中，提供命令行方式压缩和解压文件，支持文件和文件夹操作。
  - 在`compressedGUI`类里面，提供图形输入界面

### 4.2 鲁棒性（5%）

#### 需求分析与实现：

- **功能**：捕获用户输入错误，给出清晰的错误提示。
- **实现**：
  - 在文件路径、密码验证等地方使用 `try-catch` 捕获异常，避免程序崩溃。

### 4.3 文件覆盖问题（5%）

#### 需求分析与实现：

- **功能**：在输出路径中有重复文件的时候询问用户如何处理
- **实现**：
  - 在需要写入新文件时，都对现有路径进行检测，如果发现了重复的文件或文件夹都跳出弹窗让用户进行选择。

------

## 5. 开发环境与工具

- **编程语言**：`Java 21`
- **开发工具**：`Vscode`
- **版本控制**：`Git`
- **构建工具**：`Maven `

------

## 6. 性能测试

### 测试用例：

| 测试文件                             | 原始大小           | 压缩后大小         | 压缩时长  | 解压时长  | 压缩率   |
| ------------------------------------ | ------------------ | ------------------ | --------- | --------- | -------- |
| mihoyo_launcher                      | 81.3G              | 79G                | 1776.039s | 1817.233s | 2.829%   |
| testcases(开启优化后)                | 3,769,450,662 字节 | 2,556,644,478 字节 | 27.955s   | 17.339s   | 32.1746% |
| testcases(开启优化前)                | 3,769,450,662 字节 | 2,562,154,034 字节 | 137.71s   | 38.491s   | 32.0285% |
| 1.txt(内容全是1)                     | 1187542字节        | 292字节            | 0.007s    | 0.013s    | 99.9754% |
| testcase03XLargeSingleFile/3.csv     | 643,412,034 字节   | 410,445,352 字节   | 4.365s    | 2.047s    | 36.208%  |
| testcases.compressed（前）           | 2,562,154,034 字节 | 2,562,643,687 字节 | 27.562s   | 7.86s     | -0.002%  |
| testcase03XLargeSingleFile/1.jpg(后) | 20,748,242 字节    | 20,748,525 字节    | 0.046s    | 0.061s    | -0.001%  |
| testcase03XLargeSingleFile/1.jpg(前) | 20,748,242 字节    | 20,702,015 字节    | 0.538s    | 0.15s     | 0.223%   |

------

## 7. 问题、优化与解决方案

### 问题：缓存区内容有限而处理的文件很大怎么办？

- 对文件进行分块处理，同时对于块的大小不能一概而论，对于不同大小文件分不同大小的块：

~~~java
    // 获取最佳块大小
    private static int getOptimalChunkSize(long fileSize) {
        if (fileSize < 10 * 1024 * 1024) {
            return 256 * 512;
        } else if (fileSize < 100 * 1024 * 1024) {
            return 2 * 1024 * 1024;
        } else {
            return 4 * 1024 * 1024;
        }
    }
~~~



### 问题：如何在解压缩文件夹的时候还原出一个空文件夹？

- 在读取所有文件目录的时候将空文件夹也视为一个文件，并且加上一个空文件夹判断位。

### 问题：如何提高压缩和解压缩的速度？

- 在压缩和解压缩的时候加入多线程处理，对于大文件的处理能够加快很多

- 多线程本身是一次冒险的尝试，涉及到了很多意想不到的问题。比如异步处理的时候如果出现了密码错误就会很难同时中止所有进程，这样就会出现一直在不停地弹窗这样的病毒性行为，如下图 ![](C:\Users\27556\Pictures\联想截图\联想截图_20241202145631.png)

  因而不得不在操作一开始就验证密码，过程中解码才会不出现问题。

- 除了上面那种情况之外，java heap space是一个更烦人的错误，它同样也会出现上面那样的画面，因为异步线程所以停不下来，所以对于需要缓存区较大的超大文件（>1/4G），就不得不只能放弃一直向future的列表中加入，而是在future已经存入了一定量以后将其先行输出，这样保证了JVM的内存不会溢出，同时也保留对小文件的正常处理，以最大限度地提高速度。

- 另外，多线程还有个问题，你不知道哪个线程会先运行好，所以我必须给每个块编上号，在写入之前进行排序，这样才能保证不会出现分块顺序混乱的问题。我曾经因为这个把那个19.7M的1.jpg五等份然后随机重新排列了，有点遗憾没有把当时的照片保存下来。

- 对加密的类也做了一定的优化，具体如下：

  **密钥缓存**：缓存已经派生过的密钥，减少了重复计算的开销。

  **线程局部存储**：为每个线程分配独立的 `Cipher` 实例，避免了线程间的竞争和重复创建实例的开销。

  **减少迭代次数**：通过减少密钥派生算法的迭代次数，提升了密钥派生的速度。原本迭代次数是66356次，运行速度被硬生生增加了一倍。

  **AES 加密算法**：采用 AES，这是一种高效且安全的加密算法，适合用于高性能的加密应用。

- 对底层编码和解码的两个类，**尽量使用字符串组**，而不使用Map之类的数据结构尽量减少时间复杂度，**使用显式栈代替递归**，在 `buildHuffmanCodesIterative` 方法中，使用显式栈来代替递归来构建霍夫曼编码。这种方式可以避免递归调用带来的函数栈开销，尤其是在树深度较大的情况下，递归可能会导致栈溢出或者增加额外的函数调用时间。

- 对于一些压缩率极低甚至为负数的一些文件类型，比如说图片类型，这些文件的压缩本身就会拖累压缩的速度，甚至会减小压缩率，所以对于这类文件，我做了一个压缩优化按钮，即自由选择对这些文件的处理，若是选择优化这些文件则会直接进入加密而不进行哈夫曼树的生成和编码，这样可以提高运行速度。当然选择权在用户手里，用户可以选择不点优化。~~（值得一提的是，一开始的时候只想着跳过图片，后面就想着拓展到那些压缩率比较低的文件上，中间的与或逻辑还写错了一次，导致我的版本号停滞了半天呜呜呜）~~

### 问题：如何让用户看到一定的运行信息？

- 加入进度条。在压缩和解压的时候加上金条，合理地给出现在的运行进度，有助于安定用户等待的心。我在文件夹处理的时候，一个文件写完更新一次进度条，在压缩单个文件的时候，一块压缩块压缩好了以后再更新进度条，这样可以使进度条的更新频率适中，也大致实现了进度条的功能。
- 加入信息框。原本我在调试代码的时候日志信息都是输出在终端里面的，但是后来发现其实可以输出到GUI界面让用户看到，~~看到飞速闪过的日志信息对程序员真的是一种享受~~。最初我的做法是把终端输出重定位到GUI的文本框里面，可以实现这样的效果，但是遇到了中文字符不能正常显示的问题，所以放弃了。后面就重新写了logInfo和logError函数，然后其他的类需要的时候直接调用就好了，不过这样好像会造成GUI类的一定程度上的泄露。

### 问题：AES加密算法要求密钥长度是固定的（128、192 或 256 位），那如何使得密码位数随机？

##### 解决方案：

- **`deriveKey` 方法：** 它通过使用 PBKDF2 算法（`PBKDF2WithHmacSHA256`）从密码派生出一个密钥。这个密钥的长度是由 `KEY_LENGTH`（128 位）控制的，这与 AES 的要求相匹配。
  - 例如，假设用户输入了一个长密码（比如 32 字节长），但是 `PBKDF2` 只会将其转换为一个 128 位（16 字节）的密钥，因为它限制了密钥的长度为 `KEY_LENGTH`（128 位）。
- **如何处理较长密码：** 如果用户输入的密码较长，`PBKDF2` 会使用盐（`SALT`）和多次迭代的方式将长密码转换成一个 128 位的 AES 密钥。这样，最终得到的密钥就符合 AES 的要求，即 128 位（16 字节）。

##### 密钥派生过程：

1. **密码与盐（SALT）结合：** 输入的密码和一个固定的盐值被传入到 PBKDF2 算法中。
2. **多次迭代：** `ITERATION_COUNT` 决定了迭代的次数，这个值越大，密码破解所需的时间就越长，提高了安全性。
3. **生成 128 位密钥：** 最终输出的密钥长度是由 `KEY_LENGTH` 决定的，这里是 128 位（16 字节）。

### 问题：使用终端输入用户可能输入奇奇怪怪的东西，如何解决？

- 使用GUI就好啦，图形化界面规定了输入的位置，这样程序的鲁棒性就大大提升了，此外，还可以在输入框下面适当的加入以下信息提示，这样的使用体验还是挺好的。
- 使用浏览按键。浏览按键可以打开文件浏览，从平时习惯的目录下找到文件，然后自动键入文件地址，这样的话不仅用户省事，我们这些处理输入的也省心。

------

## 8. 结论

本项目实现了一个基于霍夫曼编码的压缩工具，支持图形界面与命令行操作，能够处理大文件、文件夹及加密压缩包。代码设计遵循良好的面向对象设计原则，功能齐全，性能良好，能够满足用户对文件压缩和解压的需求。