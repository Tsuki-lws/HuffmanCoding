# 开发文档

## 1. 项目概述

本项目实现了一个基于 **霍夫曼编码** (Huffman Coding) 算法的文件压缩和解压工具，支持压缩和解压文件以及文件夹。项目支持命令行界面（CLI）操作，具备文件和文件夹的递归压缩解压、文件加密、错误提示等功能。用户可以通过该工具对大文件（>4GB）、空文件以及不同层级的文件夹进行压缩与解压，且支持文件加密和密码验证。

------

## 2. 项目结构

### 2.1 目录结构
```
├── src/
│   ├── Utils.h                              // `Utils.cpp` 的头文件，定义了辅助功能和工具函数。
│   ├── Utils.cpp                            // 包含辅助功能和工具函数的实现。
│   ├── CLI.h                                // `CLI.cpp` 的头文件，定义了命令行类。
│   ├── CLI.cpp                              // 实现命令行与用户交互。
│   ├── HuffmanTree.h                        // `HuffmanTree.cpp` 的头文件，定义了霍夫曼树和节点类。
│   ├── HuffmanTree.cpp                      // 实现霍夫曼树的创建和编码生成。
│   ├── fileIO.h                             // `fileIO.cpp` 的头文件，定义了文件读写和压缩解压功能。
│   ├── fileIO.cpp                           // 实现文件的读写、压缩和解压功能。
│   ├── features.h                           // `features.cpp` 的头文件，定义了文件夹压缩解压功能。
│   ├── features.cpp                         // 实现文件夹的压缩和解压功能。
│   ├── main.cpp                             // 程序入口，调用主要功能。
|
├── 开发文档.md                              // 项目开发文档，记录项目概述、结构、需求和解决方案等。
```

### 2.2 主要类，函数及功能

#### 1. `HuffmanNode` 类

- **功能**：表示霍夫曼树中的一个节点，存储数据字节、频率以及左右子节点的信息。
- 核心方法：
  - `bool operator<(const HuffmanNode &node) const`：实现小顶堆的比较运算符。

#### 2. `HuffmanTree` 类

- **功能**：构建霍夫曼树，提供树的序列化与反序列化功能。
- 核心方法：
  - `void createHuffmanTree()`：构建霍夫曼树。
  - `unordered_map<char, string> createHuffmanCode()`：获取霍夫曼编码。
  - `void subCreateHuffmanCode(HuffmanNode* root, string huffmancode, unordered_map<char, string>& haffmanCode)` ://递归获取哈夫曼编码
  - `HuffmanNode* getHuffmanRoot()`：返回霍夫曼树根节点。

#### 3. `FileIO` 类

- **功能**：处理文件的压缩与解压，最低层的内容处理。
- 核心方法：
  - `map<char, long long> makeCharFreq(const string& filename)`：构建字符频率表。
  - `void compressFile(const string& filename, const string& outputFileName, const string &prefix)`：压缩单个文件。
  - `streampos decompressFile(const string& filename, const string& outputFileName, long long filesize, const streampos &startIndex)`：解压缩单个文件。

#### 4. `Features` 类

- **功能**：提供文件夹压缩解压缩功能，综合**`FileIO`类**来实现例如文件加密等的上层操作。
- 核心方法：
  - `void compress(const string& filename, const string& outputFileName, const string &password)`：压缩文件或文件夹。
  - `void decompress(const string& filename, string& outputFileName, int passLength)`：解压缩文件或文件夹。
  - `bool isDirectory(const string& filename)`：判断是否是文件夹。

#### 5.`CLI` 类

- **功能**：处理命令行接口，与用户交互。
- 核心方法：
  - `void parseArguments(int argc, char* argv[])`：解析命令行参数。
  - `void displayHelp()`：显示帮助信息。

#### 6.`Utils`函数

- **功能**：提供各种辅助功能和工具函数。
- 核心方法：
  - `int checkOutputPath(const string &filepath)`：检查输出路径是否存在，并提示用户选择操作，用于压缩。

  - `long long* getCompressDirSize(const string& filename, int filenameSize)`:获得每个文件的压缩文件的大小
  - `int checkOutputPath(const string &filepath)`:检查输出路径是否存在,并提示用户选择操作，用于解压缩
  - `int coverAll(const vector<string> &filepath, int filenameSize)`:在相同文件数过多，确认是否一键全部覆盖，还是由用户自己选择，亦或是全部跳过

------

## 3. 核心需求

### 3.1 文件的压缩与解压（30%）

#### 需求分析与实现：

- **功能**：支持压缩与解压文件，并保证压缩后的文件内容和原始文件一致。需要支持大文件（>4GB）和空文件的处理。
- **实现思路**：
  - 使用 **霍夫曼编码** 算法进行压缩，压缩后的文件大小大多数小于原始文件。
  - 为避免处理大文件时的 `int` 溢出，所有文件大小计算使用 `long` 或`long long`类型。
  - 对空文件的处理，直接将文件头内容的字节数和字符数设置为0，写入文件后直接return。

#### 实现：

- 在 `FileIO`和`Features` 类中使用霍夫曼算法压缩和解压文件，确保解压后的数据与原数据一致。
- 采用 `long` 或`long long`类型来处理大文件的大小，避免 `int` 类型溢出问题。
- 压缩时可以指定压缩包名称，解压时会自动恢复原文件名及其目录结构。

#### 注：

- **压缩单个文件时的写入顺序如下**：
  1. 先写入密码的长度和大小（没有长度为0）
  2. 使用一个字节来记录是文件，并写入文件的相对路径
  3. 写入文件头信息（字节数，字符种类数量（空文件为0）)
  4. 写入哈夫曼树
  5. 用一个字符来判段是多线程压缩还是直接压缩（有的多线程没有直接压缩快）
  6. 然后根据文件的大小分割成多个数据块，每个数据块的对应的哈夫曼压缩的数据按顺序写入压缩文件。

### 3.2 文件夹的压缩与解压（20%）

#### 需求分析与实现：

- **功能**：支持压缩与解压文件夹，递归处理子文件夹。
- **实现思路**：
  - 使用递归方式遍历文件夹及其子文件夹，压缩所有文件及文件夹结构。
  - 对空文件夹压缩时，仅压缩文件夹结构，不包含文件内容。

#### 实现：

- `Features` 类中的`compressDirectory`通过递归遍历文件夹中的每个文件和子文件夹，调用 `FileIO` 压缩文件。
- `Features` 类中的`decompressDir`读取压缩文件的文件夹信息，恢复文件夹的结构。

#### 注：

**压缩文件夹时的写入顺序如下**：

1. 先写入密码的长度和大小（没有长度为0）
2. 使用一个字节来记录是文件夹
3. 写入所记录的文件夹的数量和内容（相对路径），再写入所记录的文件的数量和名称（相对路径）
4. 循环进行5,6,7,8的操作，直至写入完毕
5. 写入文件头信息（字节数，字符种类数量（空文件为0）)
6. 写入哈夫曼树
7. 用一个字符来判段是多线程压缩还是直接压缩（有的多线程没有直接压缩快）
8. 然后根据文件的大小分割成多个数据块，每个数据块的对应的哈夫曼压缩的数据按顺序写入压缩文件。
9. 最后在文件末尾写入每个文件压缩后所占的字节数（以便读取和跳过）

### 3.3 设置压缩密码（15%）

#### 需求分析与实现：

- **功能**：在压缩时可以选择设置密码，解压时需要输入密码。
- **实现思路**：
  - 在压缩时，用户可以设置密码，密码可以直接编码进文件头中。
  - 如果文件是加密压缩的，解压时要求用户输入密码，若密码正确，则解压。

#### 实现：

- 压缩时，直接将密码存储在压缩包头部，解压时，判断是否有密码的输入，如果有要求输入密码（见`CLI::passwordCorrect`）。

### 3.4 代码风格（5%）

#### 需求分析与实现：

- **目标**：
  - 确保代码具备良好的可读性和可维护性，便于后续扩展和维护。
  - 遵循面向对象设计原则，实现代码的模块化、职责单一和低耦合。
  - 提供清晰的注释，帮助理解代码逻辑，特别是在复杂算法（如霍夫曼编码）和核心功能部分。

#### 解决方案：

- 模块化设计：项目划分为多个功能模块，如压缩、解压、加密、用户交互和工具类模块。每个模块职责单一且功能明确。
- 避免代码冗长：复杂逻辑被拆分为多个独立的私有方法。
- 清晰的注释和命名：每段逻辑都提供了详细的注释，解释了为什么这样设计以及每一步的功能。

------

## 4. 其他需求

### 4.1 用户交互（5%）

#### 需求分析与实现：

- **功能**：用户通过命令行输入操作指令。
- **实现**：
  - 在 `Utils` 类中，提供命令行方式压缩和解压文件，支持文件和文件夹操作。

### 4.2 鲁棒性（5%）

#### 需求分析与实现：

- **功能**：捕获用户输入错误，给出清晰的错误提示。
- **实现**：
  - 在文件路径、密码验证等地方使用 `try-catch` 捕获异常，避免程序崩溃。

### 4.3 文件覆盖问题（5%）

#### 需求分析与实现：

- **功能**：在输出路径中有重复文件的时候询问用户如何处理。
- **实现**：
  - 在需要写入新文件时，都对现有路径进行检测，如果发现了重复的文件或文件夹都跳出提示让用户进行选择。

------

## 5. 开发环境与工具

- **编程语言**：`C++`
- **开发工具**：`Visual Studio Code`
- **版本控制**：`Git`

------

## 6. 性能测试

### 测试用例：

| 测试文件         | 原始大小 | 压缩后大小 | 压缩时长 | 解压时长 | 压缩率   |
| ---------------- | -------- | ---------- | -------- | -------- | -------- |
| large_file.txt   | 4.5GB    | 3.2GB      | 120s     | 110s     | 28.9%    |
| empty_file.txt   | 0B       | 0B         | 0.01s    | 0.01s    | 0%       |
| folder_structure | 1.2GB    | 800MB      | 60s      | 55s      | 33.3%    |

------

## 7. 遇到的问题与解决方案

### 问题：缓存区内容有限而处理的文件很大怎么办？

- 对文件进行分块处理，同时对于块的大小不能一概而论，对于不同大小文件分不同大小的块。

### 问题：如何在解压缩文件夹的时候还原出一个空文件夹？

- 在读取所有文件目录的时候将空文件夹也视为一个文件，并且加上一个空文件夹判断位。

### 问题：如何提高压缩和解压缩的速度？

- 在压缩和解压缩的时候加入多线程处理，对于大文件的处理能够加快很多。

### 问题：如何让用户看到一定的运行信息？

- 加入进度条。在压缩和解压的时候加上进度条，合理地给出现在的运行进度，有助于安定用户等待的心。

### 问题：AES加密算法要求密钥长度是固定的（128、192 或 256 位），那如何使得密码位数随机？

- 使用 PBKDF2 算法从密码派生出一个密钥，确保密钥长度符合 AES 的要求。

### 问题：使用终端输入用户可能输入奇奇怪怪的东西，如何解决？

- 使用命令行参数指定输入输出，避免用户输入错误。

------

## 8. 结论

本项目实现了一个基于霍夫曼编码的压缩工具，支持命令行操作，能���处理大文件、文件夹及加密压缩包。代码设计遵循良好的面向对象设计原则，功能齐全，性能良好，能够满足用户对文件压缩和解压的需求。