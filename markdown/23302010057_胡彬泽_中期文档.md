# 中期文档

## 问题 1: 哈夫曼编码算法是否总能保证最优压缩？如果不一定，请举例说明在哪些情况下它可能不是最优的。
哈夫曼编码算法在大多数情况下能保证最优压缩，但在某些情况下可能不是最优的。例如，当字符频率分布非常不均匀时，哈夫曼编码可能不是最优的。

## 问题 2: 如何根据文件的字节流，构建哈夫曼树？
- 1. 统计每个字节的出现频率。
- 2. 创建一个优先队列，将每个字节作为一个节点插入队列，优先级为其频率。
- 3. 从队列中取出两个频率最低的节点，合并成一个新节点，新节点的频率为两个节点频率之和。
- 4. 将新节点插入队列。
- 5. 重复步骤 3 和 4，直到队列中只剩一个节点，该节点即为哈夫曼树的根节点。

## 问题 3: 对于一组频率已经给定的字符，如果哈夫曼树已经构建完成，是否能快速找到一个新的字符的编码，而不重新构建整棵树？如何实现？
可以通过调整现有的哈夫曼树来快速找到新字符的编码。具体实现方法是：
- 1. 将新字符作为一个新节点插入优先队列。
- 2. 从队列中取出两个频率最低的节点，合并成一个新节点。
- 3. 重复上述步骤，直到队列中只剩一个节点。

## 问题 4: 假设对一个文件进行了哈夫曼编码压缩，如何通过编码表和压缩后的字节流，准确还原出原始文件内容？
- 1. 根据编码表构建哈夫曼树。
- 2. 从压缩后的字节流中逐位读取数据，通过哈夫曼树进行解码。
- 3. 遇到叶子节点时，输出对应的字符。
- 4. 重复上述步骤，直到读取完所有数据。

## 问题 5: 构建哈夫曼树的过程中，如何每次高效、便捷地选出出现频率最低的两个节点？
可以使用优先队列（最小堆）来高效地选出频率最低的两个节点。插入和删除操作的时间复杂度均为 O(log n)。

## 问题 6: 如何完成文件夹的压缩并保留内部文件名等信息的一致性？
- 1. 遍历文件夹，记录每个文件的路径和内容。
- 2. 对每个文件进行哈夫曼编码压缩。
- 3. 将压缩后的数据和文件路径一起存储，形成一个压缩包。
- 4. 解压时，根据存储的路径信息还原文件夹结构。

## 问题 7: 如果需要对大量的小文件进行压缩，而不是单个大文件，哈夫曼编码的效率如何？是否有优化的空间？
对大量小文件进行压缩时，哈夫曼编码的效率可能较低。可以通过以下方法优化：
- 1. 合并小文件，作为一个大文件进行压缩。
- 2. 使用其他适合小文件的压缩算法，如 LZW 或 DEFLATE。